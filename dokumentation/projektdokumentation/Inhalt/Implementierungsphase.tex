% !TEX root = ../Projektdokumentation.tex
\section{Implementierungsphase} 
\label{sec:Implementierungsphase}

test
\subsection{Erstellen einer neuen Solution}
\label{sec:ErstellungSolution}
Die Implementierung begann mit dem Anlegen eines neuen Repositories mit der vorgegebenen Verzeichnisstruktur (branch, tag, trunk) in SVN und dem Erstellen einer neuen Solution in Microsoft Visual Studio 2010. Der Solution wurde ein NUnit-Testprojekt für die Unit-Tests hinzugefügt.

\subsection{Implementierung der Datenstrukturen}
\label{sec:ImplementierungDatenstrukturen}
Die hierarchische Gliederung der Schemavariablen wird im Programm durch eine rekursive Baumstruktur abgebildet. Schemavariablen können Gruppen- oder Wertevariablen sein, Entsprechend gibt es im Programm die Klassen GroupNode und ValueNode. Die den beiden Klassen gemeinsamen Attribute und Methoden, unter anderem
\begin{itemize}
\item Level
\item VarName
\item RepeatCoung
\item RepeatIndex
\item Comment
\item AssignValue()
\item ToString()
\end{itemize} wurden in der Oberklasse AbstractNode definiert und von GroupNode und ValueNode geerbt.
GroupNodes erhielten ein Attribut children vom Typ List<AbstractNode> und können so wiederum auf weitere GroupNodes verweisen (und diese auch wieder). Dadurch kann eine beliebig tief verschachtelbare Baumstruktur repräsentiert werden. 


Die Methode, die das Schema parst, soll eine GroupNode zurückgeben. Daher musste die Implementierung mit den Klassen der Baumstruktur (AbstractNode, GroupNode und ValueNode) begonnen werden. Zum Schreiben von Unit-Tests wurde eine Methode zum vergleichen der Ergebnisse benötigt. Dazu wurden die Methoden Equals() und getHashCode() der Klasse object überschrieben. Danach wurde die Baumstruktur gemockt und die Methoden AssignValue() und ToString() implementiert.

Danach wurde die Methode Parse() der Klasse Schema geschrieben. Hier war ein Problem, dass gleichzeitig 


\subsection{Implementierung der Benutzeroberfläche}
\label{sec:ImplementierungBenutzeroberflaeche}
Die \ac{GUI} muss dem Benutzer Funktionalität bereitstellen, damit er Schema und Datenstrom angeben kann und sie muss den zergliederten Datenstrom anzeigen können.
Um diese Funktionalitäten zu bieten werden 3 Textboxen angezeigt, jeweils mit einem Label, das die Bedeutung beschreibt. Auf ein Menü wird verzichtet.

Die Angaben in den Schemadateien sind formatiert, zum Beispiel stehen Stufennummern oder Kommentare immer genau untereinander. Damit die Angaben in der Benutzerfläche auch untereinander stehen, musste für das Schema-Textfeld ein Monospace-Font verwendet (Courier New). Auch die Textfelder für Datenstrom und Ergebnis erhielten diesen Font, um das Erscheinungsbild einheitlich zu halten.
\paragraph{Beispiel}
Screenshots der Anwendung in der Entwicklungsphase mit Dummy-Daten befinden sich im \Anhang{Screenshots}.


\subsection{Implementierung der Geschäftslogik}
\label{sec:ImplementierungGeschaeftslogik}

\subsubsection{Grundschema der rekursive Methoden von AbstractNode/GroupNode}
Group- und ValueNode erben von AbstractNode Methoden. Alle diese Methoden funktionieren nach dem gleichen Prinzip:

Ist die AbstractNode eine GroupNode, dann ruft sie für jedes seiner Kinder die gleiche Methode erneut auf (Rekursion). Aus den Rückgabewerten der Kinder wird ein Wert akkumuliert und dieser zurückgegeben.
Eine ValueNode hat keine Kinder und kann direkt ein Wert zurückgeben. Bei ValueNodes und GroupNodes ohne Kindern enden die Rekursionen.



\subsubsection{Parsen des Schemas in eine Baumstruktur}
Da der Baum zwingend einen Wurzelknoten\footnote{Knoten, der Vorfahr von allen anderen Knoten ist} braucht, Schemas aber nicht zwingend einen haben, erhält der Baum einen künstlichen Wurzelknoten mit der (in Schemadateien nicht verwendeten) Stufennummer 0. Ohne Wurzelknoten würden auf höchster Ebene Geschwister ignoriert, oder es müsste statt mit GroupNode mit List<GroupNode> gearbeitet werden. Beides soll vermieden werden.

Der Algorithmus zum Parsen des Schemas nutzt einen Stack. Der Stack enthält zu jedem Zeitpunkt die Vorfahren des gerade bearbeiteten Knotens, mit seinem Elternknoten oben und dem Wurzelknoten unten.

Der Algorithmus macht folgendes:
Der künstliche Wurzelknoten wird erstellt und auf den Stack gepusht.
Aus den Schemazeilen wird eine List<AbstractNode> erstellt (unverbundene Nodes, das heißt children ist eine leere Liste für alle GroupNodes).
Im nächsten Schritt werden die unverbundenen Nodes anhand ihrer Stufennummern an der richtige Position im Baum hinzugefügt.
Dazu wird nacheinander jedes Element x der Node-Liste mit stackTop verglichen.

Es gibt drei Möglichkeiten, wie x zu stack.Peek() in Beziehung steht:
\begin{itemize}
\item er hat eine größere Stufennummer, dann ist x ein Kindknoten von stack.Peek().
\item er hat die gleiche Stufennummer, dann ist x ein Geschwisterknoten von stack.Peek().
\item er hat eine kleinere Stufennummer, dann ist x ein Kind eines Vorfahren von stack.Peek(). Der richtige Elternknoten für x muss erst noch gefunden werden.
\end{itemize}

Im Fall 1 gibt es vielleicht einen Baum unterhalb von x. x wird auf den Stack gepusht.

Fall 2 und 3 können gleich behandelt werden. Dass x kein Kindknoten von stack.Peek() ist, bedeutet, dass stack.Peek() keine weiteren Kinder hat und der Baum unterhalb von stack.Peek() vollständig ist. StackTop wird vom Stack gepoppt und (dem neuen) StackTop repeatCount mal als Kind hinzugefügt. Der Ablauf wird solange wiederholt, bis der richtige Elternknoten für x gefunden wurde.
Danach wird x (genau wie in Fall 1) auf den Stack gepusht.

Der Ablauf geht oben weiter mit der Verarbeitung der nächsten Node.

Nachdem alle Nodes der Liste durchgegangen wurden, können noch Nodes auf dem Stack liegen. Genau wie in Fall 2/3 wird StackTop vom Stack gepoppt und dem neuen StackTop als Kind hinzugefügt bis der Stack leer ist oder nur noch den Wurzelknoten enthält. Der Wurzelknoten wird zurückgegeben.


\subsubsection{Zuweisen der Werte aus dem Datenstrom}
Die Methode zum Zuweisen eines Wertes an einen Knoten hat den Prototypen 

int AssignValue(string data).

Die Methode erwartet den Datenstrom als string und gibt die Anzahl der verbrauchten Bytes zurück. Das aufrufende Objekt (normalerweise eine GroupNode) bekommt dadurch Informationen, wie viele Bytes des Datenstroms benutzt wurden. So kann der Anfang des Datenstroms für jedes Kind passend verschoben werden (und bei Redefines auch wieder zurückverschoben werden).

ValueNodes und GroupNodes machen beim Aufruf Folgendes:

ValueNodes weisen ihrem Value-Attribut die benötigte Anzahl Buchstaben aus data zu und geben diese Anzahl zurück.


GroupNodes rufen für alle ihre Kinder nacheinander AssignValue(data) auf. Jedes Kind gibt die Anzahl der verwendeten Bytes zurück. GroupNodes merken sich diese Anzahl und können dadurch für jedes Kind den Anfang des Datenstroms um diese Anzahl verschieben. GroupNode gibt die Summe der verwendeten Bytes aller seiner Kinder zurück.

\paragraph{Beispiel}
Die Klasse \texttt{Com\-par\-ed\-Na\-tu\-ral\-Mo\-dule\-In\-for\-ma\-tion} findet sich im \Anhang{app:CNMI}.  


\Zwischenstand{Implementierungsphase}{Implementierung}




