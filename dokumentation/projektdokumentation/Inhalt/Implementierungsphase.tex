% !TEX root = ../Projektdokumentation.tex
\section{Implementierungsphase} 
\label{sec:Implementierungsphase}
Zuerst legte der Autor ein neues SVN-Repository für sein Programm an.
Die Implementierung begann mit dem Anlegen eines neuen Repositories mit der vorgegebenen Verzeichnisstruktur (branch, tag, trunk) in SVN und dem Erstellen einer neuen Solution in Microsoft Visual Studio 2010. Der Solution wurde ein NUnit-Testprojekt für die Unit-Tests hinzugefügt.

\subsection{Implementierung der Datenstrukturen}
\label{sec:ImplementierungDatenstrukturen}
Die hierarchische Gliederung der Schemavariablen wird im Programm durch eine Baumstruktur abgebildet. Schemavariablen können Gruppen- oder Wertevariablen sein, Entsprechend gibt es im Programm die Klassen GroupNode und ValueNode. Die  beiden Klassen haben gemeinsamen Attribute und Methoden, unter anderem
\begin{itemize}
\item Level
\item VarName
\item RepeatCount
\item RepeatIndex
\item Comment
\item AssignValue()
\item ToString()
\end{itemize}. Diese wurden in der Klasse AbstractNode definiert und von Group- und ValueNode geerbt.
GroupNodes erhielten ein Attribut children vom Typ List<AbstractNode> und können so wiederum auf weitere GroupNodes verweisen (und diese auch wieder). Dadurch kann eine beliebig tief verschachtelbare Baumstruktur repräsentiert werden. 


Die Methode, die das Schema parst, soll den Wurzelknoten als GroupNode zurückgeben. Daher musste die Implementierung mit den Klassen der Baumstruktur (AbstractNode, GroupNode und ValueNode) begonnen werden. Zum Schreiben von Unit-Tests wurde eine Methode zum vergleichen der Ergebnisse benötigt. Dazu wurden die Methoden Equals() und getHashCode() der Klasse object überschrieben. Danach wurde die Baumstruktur gemockt und die Methoden AssignValue() und ToString() implementiert.

Danach wurde die Methode Parse() der Klasse Schema geschrieben. Hier war ein Problem, dass gleichzeitig 


\subsection{Implementierung der Benutzeroberfläche}
\label{sec:ImplementierungBenutzeroberflaeche}
Die \ac{GUI} muss dem Benutzer Funktionalität bereitstellen, damit er Schema und Datenstrom angeben kann und sie muss den zergliederten Datenstrom anzeigen können.
Um diese Funktionalitäten zu bieten werden 3 Textboxen angezeigt, jeweils mit einem Label als Überschrift. Auf ein Menü wurde zunächst verzichtet.

Die Angaben in den Schemadateien sind formatiert, gleiche Angaben wie Level oder Variablenname stehen untereinander. Damit die Angaben in der GUI auch untereinander stehen, wurde für das Schema-Textfeld ein Monospace-Font verwendet (Courier New). Um das Erscheinungsbild einheitlich zu halten, zeigen auch die Textfelder für Datenstrom und Ergebnis Ihren Inhalt mit diesem Zeichensatz an.
\paragraph{Beispiel}
Screenshots der Anwendung in der Entwicklungsphase mit Dummy-Daten befinden sich im \Anhang{Screenshots}.


\subsection{Implementierung der Geschäftslogik}
\label{sec:ImplementierungGeschaeftslogik}

\subsubsection{Grundschema der rekursive Methoden von AbstractNode/GroupNode}
Group- und ValueNode erben von AbstractNode Methoden. GroupNode definiert definiert diese Methoden rekursiv. Alle diese Methoden funktionieren nach dem gleichen Prinzip:

GroupNode ruft für jedes seiner Kinder die gleiche Methode erneut auf (Rekursion). Aus den Rückgabewerten der Kinder wird ein Wert akkumuliert und dieser zurückgegeben.
Eine ValueNode hat keine Kinder und kann direkt ein Wert zurückgeben. Bei ValueNodes und GroupNodes ohne Kindern enden die Rekursionen.



\subsubsection{Parsen des Schemas in eine Baumstruktur}
Da der Baum einen einzigen Wurzelknoten\footnote{Knoten, der Vorfahr von allen anderen Knoten ist} haben soll, Schemas aber nicht zwingend einen haben, erhält der Baum einen künstlichen Wurzelknoten mit der Stufennummer 0. Würde man keinen solchen Knoten einführen, müsste statt mit GroupNode mit List<AbstractNode> als Rückgabewert gearbeitet werden, da es auf höchster Ebene mehrere Geschwister geben kann oder Wertvariablen ohne Eltern.

Eine Schwierigkeit des Algorithmus war, dass zu jedem Zeitpunkt in mehrere Richtungen gegangen werden muss. Zum einen muss die nächste Zeile des Schemas in einen Knoten verwandelt werden. Ein Knoten kann sich aber wiederholen.
Hier hat der Autor einige Zeit verbraucht mit rekursiven Ideen.

Der Algorithmus zum Parsen des Schemas nutzt einen Stack. Der Stack enthält zu jedem Zeitpunkt die Vorfahren des gerade bearbeiteten Knotens, mit seinem Elternknoten oben und dem Wurzelknoten unten. x wird mit seinem





\subsubsection{Zuweisen der Werte aus dem Datenstrom}
Die Methode zum Zuweisen eines Wertes an einen Knoten hat den Prototypen 

int AssignValue(string data).

Die Methode erwartet den Datenstrom als string und gibt die Anzahl der verbrauchten Bytes zurück. Das aufrufende Objekt (normalerweise eine GroupNode) bekommt dadurch Informationen, wie viele Bytes des Datenstroms benutzt wurden. So kann der Anfang des Datenstroms für jedes Kind passend verschoben werden (und bei Redefines auch wieder zurückverschoben werden).

ValueNodes und GroupNodes machen beim Aufruf Folgendes:

ValueNodes weisen ihrem Value-Attribut die benötigte Anzahl Buchstaben aus data zu und geben diese Anzahl zurück.


GroupNodes rufen für alle ihre Kinder nacheinander AssignValue(data) auf. Jedes Kind gibt die Anzahl der verwendeten Bytes zurück. GroupNodes merken sich diese Anzahl und können dadurch für jedes Kind den Anfang des Datenstroms um diese Anzahl verschieben. GroupNode gibt die Summe der verwendeten Bytes aller seiner Kinder zurück.

\paragraph{Beispiel}
Die Klasse \texttt{Com\-par\-ed\-Na\-tu\-ral\-Mo\-dule\-In\-for\-ma\-tion} findet sich im \Anhang{app:CNMI}.  


\Zwischenstand{Implementierungsphase}{Implementierung}




