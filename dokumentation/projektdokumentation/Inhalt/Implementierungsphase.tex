% !TEX root = ../Projektdokumentation.tex
\section{Implementierungsphase} 
\label{sec:Implementierungsphase}
Die Implementierung begann mit dem Anlegen eines neuen SVN-Repositories mit der vorgegebenen Verzeichnisstruktur (branch, tag, trunk) und dem Erstellen einer neuen Solution in Microsoft Visual Studio Professional 2010 mit einem C\# Winforms Projekt. Der Solution wurde ein NUnit-Testprojekt für die Unit-Tests hinzugefügt.

\subsection{Implementierung der Datenstrukturen}
\label{sec:ImplementierungDatenstrukturen}
Für Gruppen- und Wertevariablen wurden die beiden Klassen GroupNode und ValueNode erstellt. GroupNode soll eine Liste mit Referenzen auf seine Kindknoten (vom Typ GroupNode oder vom Typ ValueNode) bekommen. Damit beide Klassenarten in diese Liste aufgenommen werden können, müssen sie das gleiche Interface implementieren oder von der gleichen Klasse erben. Beide Klassen haben einige Attribute gemeinsam (Level, Variablenname, Kommentar), deshalb erben sie von der abstrakten Oberklasse AbstractNode.

Diese Klassenstruktur kann einen beliebig tief verschachtelbaren AbstractNode-Baum darstellen, weil die Kindknoten-Liste von GroupNode wiederum GroupNodes enthalten kann (und diese wieder, und deren wieder, und so weiter).

Die Methode zum Parsen eines Schemas passte in keine der Klassen, sie kam in eine eigene Klasse namens Schema. Die Methode, die das Schema parst, soll den Wurzelknoten als GroupNode zurückgeben. Daher musste die Implementierung mit den Klassen der Baumstruktur (AbstractNode, GroupNode und ValueNode) begonnen werden. Zum Schreiben von Unit-Tests wurde eine Methode zum vergleichen der Ergebnisse benötigt. Dazu wurden die Methoden Equals() und getHashCode() der Klasse object überschrieben. Danach wurde die Baumstruktur gemockt und die Methoden AssignValue() und ToString() implementiert.

Danach wurde die Methode Parse() der Klasse Schema geschrieben. Hier war ein Problem, dass gleichzeitig 


\subsection{Implementierung der Benutzeroberfläche}
\label{sec:ImplementierungBenutzeroberflaeche}
Visual Studio erstellte mit Neuanlage des Winform-Projekts automatisch eine Form-Klasse, die ein Fenster darstellt.
Die \ac{GUI} muss dem Benutzer Funktionalität bereitstellen, damit er Schema und Datenstrom angeben kann und sie muss den zergliederten Datenstrom anzeigen können.
Um diese Funktionalitäten zu bieten werden 3 Textboxen angezeigt, jeweils mit einem Label als Überschrift. Auf ein Menü wurde zunächst verzichtet.

Die Angaben in den Schemadateien sind formatiert, gleiche Angaben wie Level oder Variablenname stehen untereinander. Damit die Angaben in der GUI auch untereinander stehen, wurde für das Schema-Textfeld ein Monospace-Font verwendet (Courier New). Um das Erscheinungsbild einheitlich zu halten, zeigen auch die Textfelder für Datenstrom und Ergebnis Ihren Inhalt mit diesem Zeichensatz an.
All das erforderte kein Programmieren, diese Einstellungen konnten durch Klicks und setzen von Attributen im GUI-Designer von Visual Studio gemacht werden.
\paragraph{Beispiel}
Screenshots der Anwendung in der Entwicklungsphase mit Dummy-Daten befinden sich im \Anhang{Screenshots}.


\subsection{Implementierung der Geschäftslogik}
\label{sec:ImplementierungGeschaeftslogik}
\subsubsection{Parsen des Schemas in eine Baumstruktur}
\paragraph{Parsen einer Variablenzeile zu einer AbstractNode}
Jede Variablenzeile im Schema wird zu einer Group- oder ValueNode. Dazu wurde in der Klasse Schema die Methode ParseLine geschrieben. Die Methode splittet die Angaben einer Variablenzeile mit Hilfe einer \ac{Regex} in ihre Felder auf. Die \ac{Regex} wurde auf \href{https://regex101.com}{https://regex101.com} angepasst und getestet, bis sie richtig funktionierte.

\paragraph{Erstellen des Baumes}

Eine Schwierigkeit des Algorithmus war, dass zu jedem Zeitpunkt in mehrere Richtungen gegangen werden muss. Zum einen muss die nächste Zeile des Schemas in einen Knoten verwandelt werden. Ein Knoten kann sich aber wiederholen.
Hier hat der Autor einige Zeit verbraucht mit rekursiven Ideen.

Zur Lösung des Problems führte die Idee, einen Knoten nach dessen Erstellung zu Kopieren.

Der Algorithmus zum Parsen des Schemas nutzt einen Stack. Der Stack enthält zu jedem Zeitpunkt die Vorfahren des gerade bearbeiteten Knotens, mit seinem Elternknoten oben und dem Wurzelknoten unten.



\subsubsection{Grundschema der rekursive Methoden von AbstractNode/GroupNode}
Group- und ValueNode erben von AbstractNode Methoden. Die Implementierung all dieser Methoden ähnelt sich, sie folgt für Group- und ValueNodes diesem Ablauf:

ValueNode macht eine Aktion und gibt danach einen Wert zurück.

GroupNode macht eine Aktion und ruft danach für jedes seiner Kinder die gleiche Methode erneut auf (Rekursion). Aus den Rückgabewerten der Kinder wird ein Wert akkumuliert und dieser zurückgegeben.

Die von einer GroupNode angestoßenen Rekursionen enden bei ValueNodes und GroupNodes ohne Kinderknoten.

Es ist kein Zufall, dass alle Methoden rekursiv sind, denn auch die Klassenstruktur ist rekursiv.

\subsubsection{Zuweisen der Werte aus dem Datenstrom}
Die Methode zum Zuweisen eines Wertes an einen Knoten hat den Prototypen 

int AssignValue(string data).

Die Methode erwartet den Datenstrom als string und gibt die Anzahl der verbrauchten Bytes zurück. Das aufrufende Objekt (normalerweise eine GroupNode) bekommt dadurch Informationen, wie viele Bytes des Datenstroms benutzt wurden. So kann der Anfang des Datenstroms für jedes Kind passend verschoben werden (und bei Redefines auch wieder zurückverschoben werden).

ValueNodes und GroupNodes machen beim Aufruf Folgendes:

ValueNodes weisen ihrem Value-Attribut die benötigte Anzahl Buchstaben aus data zu und geben diese Anzahl zurück.


GroupNodes rufen für alle ihre Kinder nacheinander AssignValue(data) auf. Jedes Kind gibt die Anzahl der verwendeten Bytes zurück. GroupNodes merken sich diese Anzahl und können dadurch für jedes Kind den Anfang des Datenstroms um diese Anzahl verschieben. GroupNode gibt die Summe der verwendeten Bytes aller seiner Kinder zurück.

\paragraph{Beispiel}
Die Klasse \texttt{Com\-par\-ed\-Na\-tu\-ral\-Mo\-dule\-In\-for\-ma\-tion} findet sich im \Anhang{app:CNMI}.  


\Zwischenstand{Implementierungsphase}{Implementierung}




