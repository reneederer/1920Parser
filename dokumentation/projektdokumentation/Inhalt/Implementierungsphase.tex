% !TEX root = ../Projektdokumentation.tex
\section{Implementierungsphase - Zergliedern des Datenstroms} 
\label{sec:ImplementierungsphaseDatenstromZergliedern}


Die Implementierung begann mit dem Anlegen eines neuen SVN-Repositories mit der vorgegebenen Verzeichnisstruktur (branch, tag, trunk) und dem Erstellen einer neuen Solution in Microsoft Visual Studio Professional 2010 mit einem C\# Winforms Projekt. Der Solution wurde ein NUnit-Testprojekt für die Unit-Tests hinzugefügt.

\subsection{Implementierung der Benutzeroberfläche}
\label{sec:ImplementierungBenutzeroberflaeche}
Visual Studio erstellte mit Neuanlage des Winform-Projekts automatisch eine Form-Klasse, die ein Fenster darstellt.
Die GUI wurde so einfach wie möglich gehalten: 3 Textfelder mit Überschrift, jeweils für Datenstrom, Schema und Ergebnis. Es wurde noch ein Button zum Starten der Verarbeitung eingefügt. Dieser wurde im Laufe der Implementierung  entfernt und die Verarbeitung bei jeder Eingabe in Schema- oder Datenstrom-Textfeld gestartet.


\subsection{Implementierung der Geschäftslogik}
\label{sec:ImplementierungGeschaeftslogik}
\subsubsection{Parsen des Schemas in eine Baumstruktur}
\label{sec:ParsenSchema}
\paragraph{Parsen einer Variablenzeile zu einer AbstractNode}
Jede Variablenzeile im Schema wird zu einer Group- oder ValueNode. Dazu wurde in der Klasse Schema die Methode ParseLine geschrieben. Die Methode splittet die Angaben einer Variablenzeile mit Hilfe einer \ac{Regex} in ihre Felder auf. Die \ac{Regex} wurde auf \href{https://regex101.com}{https://regex101.com} angepasst und getestet, bis sie richtig funktionierte.

Eine Schwierigkeit des Algorithmus war, dass zu jedem Zeitpunkt in mehrere Richtungen gegangen werden muss. Zum einen muss die nächste Zeile des Schemas in einen Knoten verwandelt werden. Ein Knoten kann sich aber wiederholen.
Hier hat der Autor einige Zeit verbraucht mit rekursiven Ideen.

Zur Lösung des Problems führte die Idee, einen Knoten nach dessen Erstellung zu Kopieren.

Der Algorithmus zum Parsen des Schemas nutzt einen Stack. Der Stack enthält zu jedem Zeitpunkt die Vorfahren des gerade bearbeiteten Knotens, mit seinem Elternknoten oben und dem Wurzelknoten unten.



\subsubsection{Grundschema der Methoden von AbstractNode}
\label{sec:RekursiveMethoden}
Group- und ValueNode erben von AbstractNode Methoden. Die Implementierung all dieser Methoden ähnelt sich, sie folgt für Group- und ValueNodes immer diesem Prinzip:
ValueNode macht eine Aktion und gibt danach einen Wert zurück.
GroupNode macht eine Aktion und ruft danach für jedes seiner Kinder die gleiche Methode erneut auf (Rekursion). Aus den Rückgabewerten der Kinder wird ein Wert akkumuliert und dieser zurückgegeben.
Die von einer GroupNode angestoßenen Rekursionen enden bei ValueNodes und GroupNodes ohne Kinderknoten, die Abbruchbedingung der Rekursion ist polymorph.
Es ist kein Zufall, dass alle Methoden rekursiv sind, denn auch die Klassenstruktur ist rekursiv (GroupNodes können auf GroupNodes verweisen).

\Zwischenstand{Implementierungsphase}{Implementierung}











