% !TEX root = ../Projektdokumentation.tex
\section{Implementierungsphase} 
\label{sec:Implementierungsphase}

\subsection{Implementierung der Datenstrukturen}
\label{sec:ImplementierungDatenstrukturen}
Um die hierarchische Struktur der Schemadateien im Programm abzubilden, wird eine rekursive Baumstruktur implementiert. Der Baum enthält Knoten, ein Knoten kann auf andere Knoten verweisen.


Schemazeilen, die in der Ausgabe angezeigt werden sollen, können folgende Angaben enthalten:
\begin{itemize}
\item ein R, das angibt, dass dieser Knoten redefiniert
\item zweiziffrige Stufennummer
\item Variablenname
\item Typangabe
\item Anzahl der verwendeten Bytes
\item Anzahl, wie oft sich dieser Knoten wiederholt (Array).
\end{itemize}
Sufennummer und Variablenname sind Pflichtangaben und definierendes Charakteristikum für Node-Zeilen, die anderen Angaben können auch leer sein.

Schema-Items definieren entweder ValueNodes oder GroupNodes.
ValueNodes haben immer eine Angabe zum Variablentyp und eine Längenangabe zur Anzahl der Bytes aus dem Datenstrom, der ihnen zugewiesen wird.
GroupNodes haben dagegen nie einen Typ und nie eine Länge. Stattdessen können sie Kind-Knoten haben. Kind-Knoten haben immer eine größere Stufennummer als ihre Elternknoten und können GroupNodes oder ValueNodes sein.

Im Programm wird die hierarchische Gliederung der Schema-Variablen als rekursive Baumstruktur repräsentiert. Dazu wurde eine abstrakte Klasse AbstractNode definiert von denen die Klassen ValueNode und GroupNode erben. GroupNode verweist auf seine Kind-Knoten mit einer Liste vom Typ AbstractNode. GroupNode kann daher wiederum GroupNodes und ValueNodes als Kinder haben.

\subsection{Implementierung der Benutzeroberfläche}
\label{sec:ImplementierungBenutzeroberflaeche}
Die \ac{GUI} muss dem Benutzer Funktionalität bereitstellen, damit er Schema und Datenstrom angeben kann und sie muss den zergliederten Datenstrom anzeigen können.
Um diese Funktionalitäten zu bieten werden 3 Textboxen angezeigt, jeweils mit einem Label, das die Bedeutung beschreibt. Auf ein Menü wird verzichtet.

Die Angaben in den Schemadateien sind eingerückt, zum Beispiel stehen Kommentare immer untereinander. Damit die Angaben in der Benutzerfläche auch untereinander stehen, musste für das Schema-Textfeld ein Monospace-Font verwendet (Courier new). Auch die Textfelder für Datenstrom und Ergebnis erhielten diesen Font, der Einheitlich wegen.
\paragraph{Beispiel}
Screenshots der Anwendung in der Entwicklungsphase mit Dummy-Daten befinden sich im \Anhang{Screenshots}.


\subsection{Implementierung der Geschäftslogik}
\label{sec:ImplementierungGeschaeftslogik}

\subsubsection{Grundschema der rekursive Methoden von AbstractNode/GroupNode}
AbstractNode definiert eine Reihe abstrakter Methoden. Die Methoden AssignValue(), ToString() und CreateCopyWithIndex() verwendet GroupNode rekursiv. Alle diese Methoden funktionieren nach dem Gleichen Prinzip: 

GroupNode ruft für jedes seiner Kinder die gleiche Methode erneut auf. Aus den Rückgabewerten der Kinder wird ein Wert akkumuliert, dieser wird an den Aufrufer zurückgegeben.

ValueNodes haben keine Kind-Knoten. ValueNodes geben direkt einen Wert zurück.
Die Rekursionen enden bei ValueNodes und bei GroupNodes ohne Kindern.

\subsubsection{Parsen des Schemas in eine Baumstruktur}
Der Baum bekommt einen künstlichen Wurzelknoten mit der (in Schemadateien nicht verwendeten) Stufennummer 0.

Der Algorithmus zum Parsen des Schemas nutzt einen Stack. Der Stack enthält zu jedem Zeitpunkt die Vorfahren des gerade bearbeiteten Knotens, mit dem Elternknoten oben und dem Wurzelknoten unten.

Der Algorithmus macht folgendes:

Zuerst wird der künstliche Wurzelknoten erstellt und auf den Stack gepusht.

Danach durchläuft der Algorithmus jede Zeile des Schemas und erstellt aus ihr den Knoten x (eine Value- oder GroupNode, abhängig davon, ob die Zeile Angaben zu Typ und Länge hat oder nicht).


Es gibt drei Möglichkeiten, wie x zu stack.Peek() in Beziehung steht:
\begin{itemize}
\item er hat eine größere Stufennummer, dann ist x ein Kindknoten von stack.Peek().
\item er hat die gleiche Stufennummer, dann ist x ein Geschwisterknoten von stack.Peek().
\item er hat eine kleinere Stufennummer, dann ist x ein Kind eines Vorfahren von stack.Peek(). Der richtige Elternknoten für x muss erst noch gefunden werden.
\end{itemize}
Im Fall 1 wird x für weitere Verarbeitung auf den Stack gepusht.


Fall 2 und 3 können gleich behandelt werden. Dass x kein Kindknoten von stack.Peek() ist, bedeutet, dass stack.Peek() keine weiteren Kinder hat. stack.Peek() wird vom Stack gepoppt und (dem neuen) stack.Peek() als Kind hinzugefügt. Der Ablauf wird solange wiederholt, bis der richtige Elternknoten für x gefunden wurde.
Danach wird x (genau wie in Fall 1) auf den Stack gepusht.

Der Ablauf geht oben weiter mit dem Lesen der nächsten Zeile.


Nachdem alle Zeilen gelesen wurden, werden die auf dem Stack verbliebenen Elemente einander als Kinder hinzugefügt, bis der Stack nur noch den Wurzelknoten enhält. Der Wurzelknoten wird zurückgegeben.


\subsubsection{Zuweisen der Werte aus dem Datenstrom}
Die Methode zum Zuweisen eines Wertes an einen Knoten hat den Prototypen 

int AssignValue(string data).

Die Methode erwartet den Datenstrom als string und gibt die Anzahl der verbrauchten Bytes zurück. Das aufrufende Objekt (normalerweise eine GroupNode) bekommt dadurch Informationen, wie viele Bytes des Datenstroms benutzt wurden. So kann der Anfang des Datenstroms für jedes Kind passend verschoben werden (und bei Redefines auch wieder zurückverschoben werden).

ValueNodes und GroupNodes machen beim Aufruf Folgendes:

ValueNodes weisen ihrem Value-Attribut die benötigte Anzahl Buchstaben aus data zu und geben diese Anzahl zurück.


GroupNodes rufen für alle ihre Kinder nacheinander AssignValue(data) auf. Jedes Kind gibt die Anzahl der verwendeten Bytes zurück. GroupNodes merken sich diese Anzahl und können dadurch für jedes Kind den Anfang des Datenstroms um diese Anzahl verschieben. GroupNode gibt die Summe der verwendeten Bytes aller seiner Kinder zurück.

\paragraph{Beispiel}
Die Klasse \texttt{Com\-par\-ed\-Na\-tu\-ral\-Mo\-dule\-In\-for\-ma\-tion} findet sich im \Anhang{app:CNMI}.  


\Zwischenstand{Implementierungsphase}{Implementierung}




