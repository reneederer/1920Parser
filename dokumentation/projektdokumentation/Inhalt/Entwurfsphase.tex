% !TEX root = ../Projektdokumentation.tex
\section{Entwurfsphase - Zergliedern des Datenstroms} 
\label{sec:Entwurfsphase}

\subsection{Zielplattform}
\label{sec:Zielplattform}
Das Programm soll auf den Entwicklerrechnern der Phoenix unter Windows 7 laufen. 
Die Wahl der Programmiersprache wurde zunächst auf die bei Phoenix eingesetzten Sprachen COBOL, C++ und C\# eingegrenzt. COBOL schied als Programmiersprache für ein Windows-Tool aus,  aber C++ mit Qt und C\# waren beide geeignet. Die hohe Performance, die C++ verspricht, wurde für 1920Parser aber nicht wirklich benötigt. Die Wahl fiel auf C\# aufgrund von dessen Garbage Collection, Linq und gutem GUI-Designer.

\subsection{Aufbau der Schemadateien}
\label{sec:AufbauSchemas}
Zur Analyse des Aufbaus der 1920Schemas fragte der Autor Herrn Kemmer nach den Namen der 10 wichtigsten Schemadateien und ludt diese unter Verwendung von OpenText HostExplorer 2014 vom Mainframe herunter.

Level und Name sind Pflichtangaben, alle anderen Felder dürfen leer sein. Typ und Byteanzahl treten nur zusammen auf, solche Variablen sind Wertvariablen (sie definieren Bytes aus dem Datenstrom). Variablen ohne Typ und Bytezahl sind Gruppenvariablen.
Zusätzlich zu diesen Variablenzeilen enthalten 1920Schemas Zeilen mit Metainformationen zum Schema. Die Metainformationen sind für 1920Parser nicht relevant und werden ignoriert.

Es ergaben sich unerwartet Schwierigkeiten beim Feld Kommentar. In der Schemadatei IOVK92 gab es eine Variable, deren Kommentar-Feld mit "0" begann. Es musste eine Regel festgelegt werden, damit diese 0 nicht als Wiederholzahl interpretiert wird, sondern als Kommentar-Beginn. Es gab die Möglichkeiten, 0 als Wiederholzahl zu verbieten oder die untereinander-stehende Anordnung der Variablenfelder auszunutzen. Falsche Annahmen hätten zu Fehlfunktion des Programms geführt; es war deshalb nötig, Rücksprache mit dem Auftraggeber zu halten. Auf dessen Vorschlag und nach erneuter Prüfung der Schemadateien wurde festgelegt, dass ein Kommentar mit mindestens 2 Leerzeichen vom vorhergehenden Feld getrennt sein muss.

\subsection{Architekturdesign}
\label{sec:Architekturdesign}
Während der Projekterstellung wurde auf Kohärenz der Klassen geachtet und gegebenenfalls refaktorisiert (zum Beispiel stand die Funktionalität zum Lesen und Schreiben der XML-Config ursprünglich auch in der Klasse Schema, wurde später aber in die neu erschaffene Klasse SchemaManager ausgelagert). Im Projektverlauf entstand eine 3-Schichten-Architektur mit den Klassen 1920ParserView und SaveSchemaView als Teil der Präsentationsschicht, den Klassen AbstractNode, GroupNode, ValueNode und Schema auf Logikschicht und SchemaManager und SchemaConfig als Teil der Datenhaltungsschicht. Klassen der Präsentationsschicht und Klassen Datenhaltungsschicht kennen sich nicht und deren Objekte kommunizieren auch nicht direkt miteinander.

\subsection{Entwurf der Benutzeroberfläche}
\label{sec:Benutzeroberflaeche}
Der Kunde hatte keine Vorgaben bezüglich der Benutzeroberfläche gemacht. 
Nachdem als Programmiersprache C\# feststand, kamen für die \ac{GUI} nur  Plattformen aus dem .NET-Framework in Betracht. Da Benutzer Schemas speichern können sollen, wäre ein Webinterface (ASP.NET) mit zusätzlichem Aufwand verbunden gewesen (Benutzerverwaltung/Datenbank). \ac{WPF} und Winforms waren beide geeignet. Der Autor entschied sich für Winforms, weil er damit mehr Erfahrung hatte.

\subsection{Geschäftslogik}
\label{sec:Geschaeftslogik}
Die hierarchische Aufbau von 1920Schemas lässt sich gut mit einer rekursiven Baumstruktur im Programm abbilden. 
Für die Baumstruktur wurde die abstrakte Klasse AbstractNode entworfen. Von dieser Klasse erben die Klassen GroupNode und ValuNode, die Gruppen- und WerteVariablen darstellen. GroupNode soll ein Attribut children vom Typ List<AbstractNode> erhalten, mit dem es auf seine KindKnoten verweist. GroupNodes erlauben durch ihre rekursive Definition eine beliebig tiefe Verschachtelung von AbstractNodes.

Ein Klassendiagramm, welches die Klassen der Anwendung und deren Beziehungen untereinander darstellt kann im \Anhang{app:Klassendiagramm} eingesehen werden.


\subsection{Maßnahmen zur Qualitätssicherung}
\label{sec:Qualitaetssicherung}
Das korrekte Parsen von 1920Schemas und die richtige Zergliederung des Datenstroms sind zentral für 1920Parser. Um sicherzugehen, dass dieser Programmteil funktioniert,  wurden daher die Methoden der Klassen Schema, Abstract-, Group- und ValueNode  testgetrieben entwickelt.

\subsection{Pflichtenheft/Datenverarbeitungskonzept}
\label{sec:Pflichtenheft}
Ein Auszug aus dem Pflichtenheft ist im \Anhang{app:Pflichtenheft} zu finden.


\Zwischenstand{Entwurfsphase}{Entwurf}
